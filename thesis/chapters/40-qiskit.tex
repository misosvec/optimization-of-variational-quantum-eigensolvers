\chapter{Qiskit}\label{ch:qiskit}
This chapter describes a solution that we use for programming quantum computers and working with quantum algorithms. 

Do not confuse programming a quantum computer with standard high-level programming as we know it from classical computers, we are not there yet. The programming of quantum computers is more like programming in assembly language. A thorough knowledge of computer's hardware and architecture is crucial in assembly language programming, as it involves the manipulation of hardware through the use of low-level instructions. A similar principle is applied here, we have qubits and we manipulate them using quantum gates. For this purpose, we decided to go with an open-source Qiskit (Quantum Information Science Kit)~\cite{qiskit} library for Python backed by IBM.
% For this purpose sa tu vobec nehodi

There are also other alternatives like Cirq (by Google)~\cite{cirq}, Pennylane (by Xanadu)~\cite{pennylane}, Q\# (by Microsoft)~\cite{qsharp}, Sliq (by ETH ZÃ¼rich)~\cite{sliq}, and many more. The reason why we decided on Qiskit is that it serves our purpose and it is far ahead of its competitors and competitors offer nowhere near what Qiskit offers. It is the most popular quantum computing library, it provides plenty of learning resources, tutorials, videos, and as it is open source there is a big community around it. IBM has built an entire ecosystem around it \cite{qiskit_ecosystem} with libraries for quantum machine learning, chemistry, finance, and many more. The 7-year work of IBM culminated in the middle of February 2024, when they released version 1.0.0. of Qiskit. Even though Qiskit is mainly developed by IBM, it is not limited to IBM's quantum computers, through additional packages can support a hardware of other companies.

\section{Quantum simulation}
One might question, why there is a need for a quantum computer to solve for eigenvalues when a classical computer can do it in polynomial time. This is true, but if the matrix size is exponentially large, the problem becomes untractable for classical computers and here quantum computers come into play.

We will try to illustrate the advantage of quantum computers in this simple example from Quantum Computation and Quantum Information by Michael A. Nielsen and Isaac L. Chuang~\cite{qc}. Suppose we have a system containing 50 qubits. To describe a state of such a system requires $2^{50} \approx 10^{15}$ complex amplitudes. If the amplitudes are stored in to 128 bits of precision, then it requires 256 bits or 32 bytes to store each amplitude. At total $32 \times 10^{15}$ is about $32$ thousand of terabytes. It is important to realize that with each additional qubit, the memory requirements are doubled.
In essence, we benefit from the fact that we can encode a matrix of size $2^n \times 2^n$. We can encode the matrix into a quantum computer using $n$ qubits, therefore the number of qubits grows $O(poly(n))$.